#' Remove retention time for MS2 libraries
#'
#' \code{remove_rt} offers a way to remove all retention time for MS2 library.
#'
#' This function supports parallel computing.
#'
#' @param lib The \code{list} generated by \code{read_lib}.
#'
#' @return A \code{list} without retention time
#' @export
#'
#' @import future.apply
remove_rt <- function(lib) {
  future.apply::future_lapply(lib, function(x) {
    x$RetentionTime = NA

    return(x)
  })
}


#' Separate positive and negative modes in MS2 library
#'
#' \code{separate_polarity} offers a way to separate a MS2 library based on
#' polarity.
#'
#' Some libraries, e.g., NIST and GNPS have both positive and negative MS2
#' records mixed in a singled file. However, in practice, a MS2 library should
#' be either positive or negative based on the polarity used in the experiment.
#' Therefore, this function provides a way to separate positive and negative
#' modes in MS2 library.
#'
#' @param lib A MS2 library mixed with positive and negative modes.
#' @param polarity The polarity, can be either "pos" or "neg"
#'
#' @return A \code{list}, being positive or negative
#' @export
#'
#' @import rlist
#' @importFrom rlang .data
separate_polarity <- function(lib, polarity) {
  if(polarity == "pos") {
    tmp <-
      rlist::list.filter(
        lib, grepl("positive", .data$IonMode, ignore.case = TRUE))
  } else {
    tmp <-
      rlist::list.filter(
        lib, grepl("negative", .data$IonMode, ignore.case = TRUE))
  }

  return(tmp)
}


#' Add formula to the mgf library
#'
#' \code{complete_mgf} offers a way to complete the molecular formula filed in
#' the mgf file.
#'
#' The mgf file downloaded from GNPS has no molecular formula (MF). Therefore, this
#' function tries to calculate the MF from the SMILES (if it exists).
#'
#' @param lib The \code{list} generated by \code{read_lib} from mgf library.
#'
#' @return A \code{list} with molecular formula assigned
#' @export
#'
#' @import future.apply
#' @rawNamespace import(ChemmineR, except = c(groups, view))
complete_mgf <- function(lib){
  future.apply::future_lapply(lib, function(x) {
    if (x$Smiles != "N/A") {
      x$Formula <-
        ChemmineR::MF(ChemmineR::smiles2sdf(x$Smiles), addH = TRUE)[[1]]
    } else {
      x$Formula <- NA
    }

    return(x)
  })
}
